<template>
  <div class="about">
    <h3>Proje Gelişimi Hakkında</h3>
<p>Projede, Prisma kullanarak PostgreSQL veritabanı ile etkileşim sağladım. API endpointleri aracılığıyla <code>department</code> tablosundaki tüm kayıtları çekip döndüren fonksiyonlar oluşturdum. Prisma Client’ı modüler yapıda tanımlayarak, veritabanı işlemlerini merkezi ve yeniden kullanılabilir hale getirdim.</p> <p>TypeScript ile <code>Department</code> arayüzü tanımlayarak, departmanların sahip olması gereken alanları (id, name, income, expense, company) tip güvenli şekilde belirledim. Bu sayede veri yapısının tutarlılığını sağladım.</p> <p>Frontend tarafında, Vue 3’ün reaktif özellikleri olan <code>computed</code> ve <code>ref</code> kullanarak departman listesini dinamik biçimde yönettim. Şirket isimlerini benzersiz olarak listeleyen bir <code>computed</code> değer oluşturdum. Toplam gelir ve gider hesaplama fonksiyonları yazdım ve bu değerleri Türkçe yerel ayarlarına uygun biçimde formatladım.</p> <p>UI katmanında Vuetify kütüphanesini entegre ederek, bileşen bazlı ve stil açısından tutarlı bir arayüz oluşturdum. Vuetify’ı Nuxt plugin olarak tanımlayarak, proje genelinde kullanılabilir hale getirdim.</p> <p>Veri çekme işlemleri için Nuxt’un <code>useFetch</code> fonksiyonunu kullanarak verileri serverdan çektim. Yükleme sürecinde <code>pending</code> durumunu takip ederek, kullanıcıya yükleniyor animasyonları gösterdim. Bunu <code>vue3-loading-skeleton</code> paketi ile gerçekleştirdim. Veri geldikten sonra, departman ve şirket bazında grafik bileşenlerini dinamik şekilde render ettim.</p> <p>Grafik görselleştirmelerinde <code>vue-chartjs</code> ve <code>chart.js</code> kütüphanelerini kullandım. Departman bazında gelir ve gider verilerini bar grafik olarak gösteren dinamik bileşenler oluşturdum. Şirket bazında ise, gerekli modülleri (<code>CategoryScale</code>, <code>BarElement</code> vb.) <code>ChartJS.register()</code> ile kayıt edip, grafik konfigürasyonlarını detaylı şekilde yapılandırdım. Böylece şirketlerin toplam gelir ve giderlerini karşılaştırmalı olarak görselleştirebildim.</p> <p>Genel olarak, backend’den frontend’e tam entegre, tip güvenli, reaktif ve modüler bir veri görselleştirme sistemi geliştirdim. Bu sistem kullanıcı dostu, sürdürülebilir ve kolay genişletilebilir yapıya sahiptir.</p> <p>VS Code da Frontend ve backend yapısını tamamıyla bitirdikten sonra bir sonraki adım olan backend yapısını VS da Web API projesine taşındı. Katmanlı mimari ile BusinessLayer, DataAccessLayer ve EntityLayer katmanları eklendi. EntityLayer da Context klasörü oluşturuldu ve içerisinde Department tablosu tanımlandı. DataAccessLayer da Context klasörü içerisinde AppDbContext classı oluşturulup database bilgileri tanımlandı. BusinessLayer katmanında ise öncelikle DepartmentServices classı oluşturuldu ve metodlar tanımlandı. Sonrasında <code>Data Transfer Object (DTO)</code> ile istenilen verilerin gerekli metodlarda işlem görmesi sağlandı. <code>AutoMapper</code> ile farklı veri nesnelerinin otomatik olarak eşleştirilerek dönüştürülmesini ve kopyalanması sağlandı. Frontend tarafında <code>nuxt.config.ts</code> dosyasında apiBase olarak backend’in çalışma URL’ini tanımladım. Artık Prisma yapılarını kaldırdım ve /api altındaki tüm istekleri yakalayan <code>[...].ts</code> dosyasını ekledim. Gelen istekleri config’teki apiBase adresine proxy’leyerek, frontend → Nuxt → backend API şeklinde bir yapı kurdum. Böylece CORS ve güvenlik sorunlarını azalttım; ayrıca API URL’leri de doğrudan frontend tarafında görünmüyor. <code>Dependecy Injection</code> ile UserService ve DepartmentService'i uygulamaya ekleyip, ihtiyaç duyulan yerlere otomatik olarak verilmesini sağladım. Generic yapı ile daha temiz, kalıtım kullanılmış ve okunaklı olup ekip üyelerinin anlayabileceği bir şekilde yapı oluşturmak için Generic yapıya geçtim. Bunun için yeni bir <code>Core</code> katmanı oluşturdum. İlk olarak, tüm veri modellerinin ortak özelliklerini taşıyan bir BaseEntity sınıfı oluşturarak, Id gibi ortak alanları tek bir yerden yönetilebilir hale getirdim. Ardından, CRUD işlemlerini her model için ayrı ayrı yazmak yerine, tüm Entityler için geçerli olan <code>Generic</code> yapılı olan EntityService geliştirdim. Bu servis sınıfı CRUD işlemlerini tek bir yerde tanımlayarak kod tekrarını önledi. Bu servisi IEntityService üzerinden dışarıya sundum, böylece bağımlılıkları soyutladım ve test edilebilirliği artırdım. API tarafında bu servisle uyumlu çalışan generic bir controller sınıfı olan <code>BaseController</code> 'ı oluşturdum. Bu controller sayesinde tüm Entityler için ayrı controller yazmadan CRUD işlemlerini gerçekleştirebilir hale geldim. Bu yapıyı kurduktan sonra ise BusinessLayer katmanında IDepartmentService ve IUserService yi IEntityService ile bağladım. Bu sayede DepartmentService ve UserService, EntityService sınıfından türetilerek Generic yapı sayesinde temel CRUD operasyonlarını miras aldı. UserService içerisinde GetQueryable metodu override edilerek kullanıcı verileri Department ilişkisiyle birlikte Include metodu aracılığıyla eager loading yöntemiyle yüklendi. Yapı oluşturulduktan sonra Nuxt projesine <code>Docker</code> entegrasyonu gerçekleştirerek uygulamanın containerization sürecini tamamladım. <code>Node.js</code> tabanlı resmi base image kullanarak bağımlılık yönetimi, kod kopyalama ve Nuxt uygulamasının statik build işlemlerini tanımlayan optimize edilmiş bir <code>Dockerfile</code> hazırladım. Dockerfile içerisinde <code>multi-stage</code> build yapısı kullanarak imaj boyutunu minimize ettim ve runtime ortamını izole ettim. Ayrıca, çoklu container senaryoları için servis orkestrasyonunu sağlamak amacıyla <code>docker-compose.yml</code> dosyası oluşturdum. Bu dosyada, servislerin network yapılandırmaları, port mapping, environment variable yönetimi ve volume mount gibi bileşenler tanımlandı. Böylece uygulamanın bağımlılıklarıyla birlikte ölçeklenebilir ve taşınabilir bir mimari üzerinde çalışması sağlandı. Bu altyapı, CI/CD pipeline entegrasyonuna uygun hale getirilerek geliştirme, test ve üretim ortamları arasında tutarlı ve tekrarlanabilir deploy süreçleri oluşturdu. Docker tabanlı containerization, microservice mimarileri için temel oluştururken, uygulamanın izolasyonu, sürdürülebilirliği ve ortamlar arası uyumluluğunu artırdı. Docker kurulumundan sonra ise Türkiye Haritası üzerinde seçilen ilde bulunan şirketleri ve departmanlarını gösteren bir yapı istenildi. Bunun üzerine GitHub üzerinden <code>SVG</code> formatlı Türkiye Haritası dosyası alındı. <code>jQuery Vector Map</code> (jqvmap) eklentisi kullanılarak görselleştirildi. Harita, <code>jquery.vmap.turkey.js</code> dosyası ile Türkiye'ye özel hale getirildi. Kullanıcı haritadan bir il seçtiğinde, o ile ait plaka kodu <code>CityCode</code> üzerinden Vue tarafında useFetch fonksiyonu ile bir HTTP isteği atıldı. Bu istek GET /api/Departments/bycity/{cityCode} endpoint’ine giderek, seçilen ile ait departmanları çekti. Kodun başında 0 olabileceği için CityCode alanı backend tarafında string veri tipiyle tanımlandı. Backend kısmında, IDepartmentService arayüzüne GetByCityCode isimli bir metot eklendi. Bu metot DepartmentService içinde implemente edilerek, Entity Framework üzerinden Where sorgusu ile şehir koduna göre filtreleme yapıldı. <code>ProjecToDTO</code> kullanılarak veriler doğrudan DTO’ya dönüştürüldü ve performanslı şekilde veritabanından çekildi. Bu işlemde AutoMapper konfigürasyonu kullanıldı. Frontend’de veriler yüklenene kadar kullanıcı deneyimini iyileştirmek amacıyla v-skeleton-loader bileşeniyle loading animasyonları gösterildi. Seçilen ile ait departman bilgileri kart görünümünde kullanıcıya sunuldu. Bu sayede hem harita ile etkileşimli hem de veri görselleştirmesi açısından modern bir yapı kurulmuş oldu. Projeye <code>i18n</code> paketini yani çoklu dil desteği entegrasyonu gerçekleştirdim. Nuxt ekosisteminde yaygın kullanılan @nuxtjs/i18n modülünü kullandım. <code>nuxt.config.ts</code> dosyasında modül yapılandırmasını gerçekleştirdim. Burada, desteklenen <code>locales</code> diller olarak tr (Türkçe) ve en (İngilizce) tanımlandı ve language files <code> locales/</code> dizininde yönetildi. Her dil dosyasında uygulamanın metin içerikleri için anahtar-değer (key-value) bazlı çeviri mesajları tanımlandı. Bu mesajlar, uygulama genelinde <code>t()</code> fonksiyonu ile çağrılarak dinamik çeviri sağlandı. Tarayıcı dil algılama mekanizması aktif edilerek, kullanıcının tercih ettiği dil bilgisi <code>cookies</code> üzerinden saklandı. Böylelikle, kullanıcı sayfalar arası geçiş yapsa dahi dil tercihinin korunması sağlandı. Vue bileşenlerinde, <code>useI18n</code> kompozisyon API’si kullanılarak dil yönetimi gerçekleştirildi. Dil değiştirme işlemi için <code>useSwitchLocalePath</code> fonksiyonu kullanılarak, mevcut rotanın seçilen dile uygun karşılığı oluşturuldu. Bu yeni rota, Vue Router’ın <code>router.push()</code> metodu ile programatik olarak kullanıcıya yönlendirildi. Böylece sayfa yeniden yüklenmeden, SPA mantığında hızlı bir dil değişimi sağlanmış oldu. Navigasyon çubuğunda, desteklenen dillerin listelendiği ve kullanıcı etkileşimi ile seçilebildiği bir dil <code>locale switcher</code> oluşturuldu. Aktif dil, reaktif computed property olarak takip edilip, seçili dile özel stil sınıfı active uygulanarak kullanıcıya görsel geri bildirim sağlandı.
</p>
</div>
</template>
<style scoped>
.about {
  max-width: 1000px;
  margin: 3rem auto;
  padding: 0 2rem;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: #f9fafd;
  color: #2c3e50;
}
.about h3 {
  color: #27ae60;
  margin-bottom: 0.8rem;
  font-weight: 800;
  font-size: 1.7rem;
  border-left: 6px solid #27ae60;
  padding-left: 10px;
  user-select: none;
}
code{
  background-color: #2c3e504b;
  border-radius: 15px;
  padding: 1px 3px;
}
</style>
